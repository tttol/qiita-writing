---
title: 'Javaのスレッドモデル：グリーンスレッドモデル・ネイティブスレッドモデル・M:Nモデル'
tags:
  - Java
private: false
updated_at: '2024-05-24T08:14:27+09:00'
id: d2b78a91eded6ce3d655
organization_url_name: null
slide: false
ignorePublish: false
---
## 前提知識
- Javaのスレッド処理にはJavaスレッドとOSスレッドの二種類が存在する
- Javaスレッド
    - JVM内で生成されるスレッド
    - java.lang.Threadクラスで生成する
    - Javaスレッド自体は処理を実行しない
- OSスレッド
    - OSが管理するスレッド
    - Javaスレッドとマッピングされ、Javaアプリの処理を実行する


## グリーンスレッド
グリーンスレッドモデルでは、JavaスレッドとOSスレッドがN対1で紐づきます。
OS側が1なので、シングルコアCPUに適したモデルです。

Java 1.0がリリースされた頃、CPUはシングルコアの時代でした。

CPUのコア数については以下記事が一番わかり易いと思ってます。

https://www.pc-koubou.jp/magazine/23926

CPUのコアを厨房のシェフに例えると、
- クロック数・・・シェフ1人あたりの仕事の速さ
- コア数・・・シェフの人数
- スレッド数・・・シェフ1人が利用するコンロ数

と言えます。


## ネイティブスレッド
ネイティヴスレッドモデルでは、JavaスレッドとOSスレッドが1対1で紐づきます。

Javaスレッド側がNから1に減ったのでスループットが落ちたように見えますが、そんなことはありません。
実際は1対1の組のスレッドを大量に生成し、OS側に複数スレッドを処理させています。

これは、CPUがマルチコアになったゆえできる芸当です。

## M:N
M:Nモデルはその名の通り、JavaスレッドとOSスレッドがM対Nで紐づきます。
ただし、M>Nです。

Java 21からGAされたVirtual Threads(仮想スレッド)はこのスレッドモデルを採用しています。

従来のネイティヴスレッドではスレッドを1つ生成するたびにOS側でスレッドが増えます。
OSスレッドはシステムコールで生成され、カーネルモードで管理されるので負荷が高くなります。
またコア数以上のスレッドを生成した際のコンテキストスイッチの負荷も高いです。

そうした辛さを克服するためのスレッドモデルがM:Nモデルです。

JavaのVirtual ThreadsはJVMで管理されるので、OSスレッドに比べて負荷が少ないです。
(JVMはユーザーモードで操作できる）
Virtual Threadsは軽量なのでJVMが許す限りは大量に生成できます。どのVirtual ThreadsがどのOSスレッドの処理を実行するかもJVMがスケジューリングします。

## 参考

https://zenn.dev/tfutada/articles/5c8f151d814c6a

https://zenn.dev/tetsu_koba/articles/e197c25899cd85

https://devlog.atlas.jp/2023/03/29/5065

https://gihyo.jp/article/2022/08/tfc003-java19
