---
title: 'OAuth 2.0, Open ID Connect, SAMLの整理'
tags:
  - OAuth
  - SAML
  - OIDC
private: false
updated_at: '2025-07-08T06:53:34+09:00'
id: 04ebe690c2291ba531e2
organization_url_name: null
slide: false
ignorePublish: false
---
出会うたびに調べ直している認証認可周りの仕様について、自分用に整理資料を作ることにしました。

# 認証・認可とは

- 認証/Authentication ＝ ユーザーが誰なのかを確かめる
- 認可/Authorization ＝ ユーザーの行動を許可する

自分は免許証の例えが一番わかりやすくしっくりくると思っています。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/159675/2443aa53-2260-41d5-85f6-9137009e5011.png)

参考:
https://speakerdeck.com/minorun365/yasasiiren-zheng-ren-ke

# OAuth 2.0

Open Authorization 2.0 の略。

### シーケンス図

```mermaid
sequenceDiagram
    actor User
    participant ClientApp as Client Application
    participant AuthzServer as Authorization Server
    participant ResourceServer as Resource Server

    User->>ClientApp: 1. アクセス要求
    ClientApp->>AuthzServer: 2. 認可リクエスト (リダイレクト)
    AuthzServer->>User: 3. ログイン画面表示
    User->>AuthzServer: 4. ID/パスワードを送信
    AuthzServer->>ClientApp: 5. 認可コード発行 (リダイレクト)
    ClientApp->>AuthzServer: 6. アクセストークンリクエスト (認可コードを含む)
    AuthzServer-->>ClientApp: 7. アクセストークン発行 (オプションでリフレッシュトークンも)
    ClientApp->>ResourceServer: 8. リソースリクエスト (アクセストークンを含む)
    ResourceServer-->>ClientApp: 9. 保護されたリソースを返却
```

### 特徴

- OAuth 2.0 は認可のみを行う。認証は行わない。
- API の実行などに使われる

# Open ID Connect

Open ID Connect のことを以下 OIDC と記載します。

### シーケンス図

```mermaid
sequenceDiagram
    actor User
    participant RelyingParty as Relying Party (Client)
    participant OpenIDProvider as OpenID Provider (Authz Server)

    User->>RelyingParty: 1. ログイン要求
    RelyingParty->>OpenIDProvider: 2. 認証リクエスト (認可リクエスト + OpenID Connect パラメータ)
    OpenIDProvider->>User: 3. ログイン画面表示
    User->>OpenIDProvider: 4. ID/パスワードを送信
    OpenIDProvider->>RelyingParty: 5. 認可コード発行 (リダイレクト)
    RelyingParty->>OpenIDProvider: 6. トークンリクエスト (認可コードを含む)
    OpenIDProvider-->>RelyingParty: 7. IDトークン、アクセストークン、リフレッシュトークン発行
    RelyingParty->>OpenIDProvider: 8. UserInfoエンドポイントからユーザ情報取得 (オプション)
    OpenIDProvider-->>RelyingParty: 9. ユーザ情報返却
    RelyingParty-->>User: 10. ログイン完了 & ユーザ情報表示
```

### 特徴

- OIDC は OAuth 2.0 の拡張仕様
- OIDC は認可に加えて認証も行う
- アクセストークンに加えて ID トークンが返却される。ID トークンにはログインユーザーの情報が含められている。
- ID トークンは JWT(JSON Web Token)と呼ばれるフォーマットで連携される。JWT は Base64URL エンコード済みの文字列であるため解読するにはデコードが必要。

```bash:JWTの例
eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

```json:デコード後のJWT
{
  "iss": "https://example.com",      // 発行者
  "sub": "1234567890",               // ユーザーID
  "aud": "client_id_abc",            // 対象クライアント
  "exp": 1719920000,                 // 有効期限（UNIX時間）
  "iat": 1719916400,                 // 発行時刻
  "name": "John Doe",                // ユーザー名（任意）
  "email": "john@example.com"        // メールアドレス（任意）
}
```

::: note info
IDトークンには任意のプロパティを追加することが可能
:::

# Grant Type の整理

### Authorization Code

- 認可コードを経由してアクセストークンを取得する。
- 2025 年時点では Authorization Code + PKCE が主流。

### PKCE

- Proof Key for Code Exchange
- 認可コードリクエスト時に`code_verifier`というランダムな文字列を一緒に送信し、サーバーで検証することで認可コードリクエストの改竄を防ぐ。

```mermaid
sequenceDiagram
    participant App as Client App
    participant AuthzServer as Authorization Server

    App->>App: code_verifier生成
    App->>App: code_challenge生成（ハッシュ化）
    App->>AuthzServer: 認可リクエスト（code_challenge含む）
    AuthzServer->>App: 認可コード発行
    App->>AuthzServer: トークンリクエスト（認可コード＋code_verifier）
    AuthzServer->>AuthzServer: code_challengeとcode_verifierを検証
    AuthzServer-->>App: アクセストークン発行
```

### Client Credentials

- クライアント単位で認証するフロー。
- `client_id`, `client_secret`をサーバー側にあらかじめ登録しておき、アクセストークンのリクエスト時にクライアントから`client_id`, `client_secret`を渡す。
- ユースケース：バックエンドのサービス間で認証したい時に有用。`client_secret`が外部に流出しないことが前提となる。

```mermaid
sequenceDiagram
    participant Client as Client App
    participant AuthzServer as Authorization Server
    participant ResourceServer as Resource Server

    Client->>AuthzServer: 1. トークンリクエスト（client_id, client_secret）
    AuthzServer-->>Client: 2. アクセストークン発行
    Client->>ResourceServer: 3. アクセストークンでAPIリクエスト
    ResourceServer-->>Client: 4. 保護リソース返却
```

### Implicit Flow(Deprecated)

- 認可コードを用いずに直接アクセストークンを返却する
- ブラウザや URL にアクセストークンが露出するリスクが高く、セキュリティ的に問題がある。よって現在は非推奨とされており、Authorization Code + PKCE が推奨されている。

```mermaid
sequenceDiagram
    actor User as User
    participant Client as Client App（SPA etc）
    participant AuthzServer as Authorization Server

    User->>Client: 1. アクセス要求
    Client->>AuthzServer: 2. 認可リクエスト
    AuthzServer->>User: 3. 認証・同意
    User->>AuthzServer: 4. 認証・同意
    AuthzServer-->>Client: 5. アクセストークンをリダイレクトURIで返却
    Client->>API: 6. アクセストークンでAPIリクエスト
```

参考:
https://oauth.net/2/grant-types/

# SAML

Security Assertion Markup Language の略。

### シーケンス図

```mermaid
sequenceDiagram
    actor User as User
    participant SP as Service Provider(SP)
    participant IdP as Identity Provider(IdP)

    User->>SP: サービスへアクセス
    SP->>User: 認証要求（リダイレクト）
    User->>IdP: 認証要求を送信
    IdP->>User: ログイン画面表示・認証
    User->>IdP: 資格情報入力
    IdP->>User: SAMLアサーション発行
    User->>SP: SAMLアサーション送信
    SP->>SP: アサーション検証
    SP->>User: サービス利用許可
```

### 特徴

- SSO の認証用途に利用される。ユースケースとしては社内システムの SSO が多い。
- Service Provider(SP)に ID/パスワードを送信することなく認証が可能（ID/パスワードは Identity Provider(IdP)にのみ送信する）。
- SAML アサーションは XML 形式の認証情報。OAuth 2.0 でいうところのアクセストークンに相当する役割を持つが、SAMLアサーションは「認証結果そのもの」を表し、アクセストークンは「リソースアクセスのためのトークン」である点が異なる。

```xml
<!-- SAMLアサーションの例 -->
<saml:Assertion>
  <saml:Issuer>https://idp.example.com/</saml:Issuer>
  <saml:Subject>
    <saml:NameID>user@example.com</saml:NameID>
  </saml:Subject>
  <saml:Conditions>
    <!-- 有効期限や制約条件 -->
  </saml:Conditions>
  <saml:AuthnStatement>
    <!-- 認証日時や方法 -->
  </saml:AuthnStatement>
  <saml:AttributeStatement>
    <saml:Attribute Name="email">
      <saml:AttributeValue>user@example.com</saml:AttributeValue>
    </saml:Attribute>
    <!-- 他の属性 -->
  </saml:AttributeStatement>
</saml:Assertion>
```
